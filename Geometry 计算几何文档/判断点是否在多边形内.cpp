///@brief 判断点是否在多边形///@param[in] p0--要判断点， poly--多边形点集合， numberOfPoints--多边形点数量///@return 2---点在多边形内， 1---点在多边边上，0---点不在多边形内///@author DionysosLai,906391500@qq.com///@retval ///@post///@version 1.0///@data 2014-04-11int HelloWorld::pointIsInPolygon(const CCPoint p0, const CCPoint* poly, const unsigned int numberOfPoints){	unsigned int count  = 0;		///< 用来标记射线L与多边形的交点数；	CCSize	winsize = CCDirector::sharedDirector()->getWinSize();	/// 已点p0向左向右做一条射线L；	CCPoint leftPoint = ccp(-100.0f, p0.y);	CCPoint rightPoint = ccp(winsize.width+100.0f, p0.y);	/// 判断每条边	for (unsigned int i = 0; i < numberOfPoints-1; i++)	{		/// 先判断点p0是否在边s上；		if (pointIsAtLine(p0, poly[i], poly[(i+1)%(numberOfPoints)]))		{			CCLOG("Point is at the %dth line", i);			return 1;		}		/// 判断边s是否是平行线；		if (poly[i].y != poly[(i+1)%(numberOfPoints)].y)		{					do 			{				/// 判断边s的是否有端点在L上 同时 再判断该点是否是边s纵坐标较大的一个点				if (pointIsAtLine(poly[i], leftPoint, rightPoint))				{					if (poly[i].y > poly[(i+1)%(numberOfPoints)].y)					{						count += 1;					}					break;				}					if (pointIsAtLine(poly[(i+1)%(numberOfPoints)], leftPoint, rightPoint))				{					if (poly[i].y < poly[(i+1)%(numberOfPoints)].y)					{						count += 1;					}					break;				}					/// 如果边s没有端点在L上，则判断s与L是否相交				if (segmentLineIsIntersect(leftPoint, rightPoint, poly[i], poly[(i+1)%(numberOfPoints)]))				{					count += 1;				}				} while (0);		}	}	if (1 == count%2)	{		CCLOG("Point is not in polygon!");		return 0;	}	else	{		CCLOG("Point is in  polygon!");		return 2;	}}///@brief 判断点是否在线段上/////////@param[in] p0--点，p1,p2--线段两个端点///@pre ///@return true---在线段上， false---不在线段上///@retval ///@postbool pointIsAtLine(const CCPoint p0, const CCPoint p1, const CCPoint p2){	/// 先判断是否点在以p1 p2为对角线的矩形内	if (pointIsInRect(p0, p1, p2))	{		/// 判断p1p0, p2p0是否共线		if (0 == PolyLineDerection(p0, p1, p2))		{			CCLOG("Point in at the line.");			return true;		}		CCLOG("Point isn't at the line.");		return false;	}	CCLOG("Point isn't at the line.");	return false;}double HelloWorld::vectorProduct(double x1, double y1, double x2, double y2)  // 行列式  {  	return (x1*y2-x2*y1);	///< 叉积 （与数学叉积不一样）} ///@brief 判断线段与线段是否相交/////////@param[in] aa,bb--线段1两个端点， cc,dd--线段1两个端点///@pre ///@return true---在线段上， false---不在线段上///@retval ///@postbool HelloWorld::segmentLineIsIntersect(CCPoint aa, CCPoint bb, CCPoint cc, CCPoint dd)  {  	/// 以两条线段形成的矩形不重合，说明两条线段必然不相交	if (!isRectCollision(aa, bb, cc, dd))	{		return false;	}	/// 必须二者互相跨立 注意"="的情况。	if (0 < vectorProduct(aa.x-cc.x, aa.y-cc.y, dd.x-cc.x, dd.y-cc.y) * 		vectorProduct(dd.x-cc.x, dd.y-cc.y, bb.x-cc.x, bb.y-cc.y) &&		0 < vectorProduct(cc.x-aa.x, cc.y-aa.y, bb.x-aa.x, bb.y-aa.y) * 		vectorProduct(bb.x-aa.x, bb.y-aa.y, dd.x-aa.x, dd.y-aa.y))	{		return true;	}	return false;  } ///@brief 判断折线的拐向，//////以线段P1为参考，；///@param[in] p1--线段1，p2--线段2///@pre P1、P1必须有公共端点///@return 1--左边 0 -- 共线 -1---右边///@retval ///@postint HelloWorld::PolyLineDerection(const CCPoint p1, const CCPoint p0, const CCPoint p2){	float vectorProductResult = 0.0f;	vectorProductResult = (float)vectorProduct(p1.x-p0.x, p1.y-p0.y, p2.x-p0.x, p2.y-p0.y);	if (vectorProductResult < 1e-3 && vectorProductResult > -1e-3)	{		CCLOG("p1p0 and p2p0 is at the same dereciton.");		return 0;	}	if (vectorProductResult >= 1e-3)	{		CCLOG("p2p0 is at p1p0's left dereciotn.");		return -1;	}	if (vectorProductResult <= -1e-3)	{		CCLOG("p2p0 is at p1p0's right dereciotn.");		return 1;	}}///@brief 判断两个矩形是否相交/////////@param[in] aa,bb--矩形1一个对角线端点， cc,dd--矩形2一个对角线端点///@pre ///@return true---相交， false---不相交///@retval ///@postbool HelloWorld::isRectCollision(CCPoint aa, CCPoint bb, CCPoint cc, CCPoint dd){	CCPoint	centre1 = ccp((aa.x + bb.x)/2.0f, (aa.y + bb.y)/2.0f);	///< 获得中点值	CCPoint	centre2 = ccp((cc.x + dd.x)/2.0f, (cc.y + dd.y)/2.0f);	float	lengthX	= abs(centre1.x - centre2.x);	///< 获得两个矩形中心的距离 	float	lengthY	= abs(centre1.y - centre2.y); 	float	lengthRect1X	= abs(aa.x - bb.x);		///< 获得两个矩形长和宽	float	lengthRect1Y	= abs(aa.y - bb.y);	float	lengthRect2X	= abs(cc.x - dd.x);	float	lengthRect2Y	= abs(cc.y - dd.y);	/// 这里减去1是调整误差用的。	return  (lengthX < (lengthRect1X + lengthRect2X)/2.0f-1 && lengthY < (lengthRect1Y + lengthRect2Y)/2.0f-1) ? true : false;}///@brief 判断线段与线段是否相交/////////@param[in] aa,bb--线段1两个端点， cc,dd--线段1两个端点///@pre ///@return true---在线段上， false---不在线段上///@retval ///@postbool HelloWorld::segmentLineIsIntersect(CCPoint aa, CCPoint bb, CCPoint cc, CCPoint dd)  {  	/// 以两条线段形成的矩形不重合，说明两条线段必然不相交	if (!isRectCollision(aa, bb, cc, dd))	{		return false;	}	/// 必须二者互相跨立 注意"="的情况。	if (0 < vectorProduct(aa.x-cc.x, aa.y-cc.y, dd.x-cc.x, dd.y-cc.y) * 		vectorProduct(dd.x-cc.x, dd.y-cc.y, bb.x-cc.x, bb.y-cc.y) &&		0 < vectorProduct(cc.x-aa.x, cc.y-aa.y, bb.x-aa.x, bb.y-aa.y) * 		vectorProduct(bb.x-aa.x, bb.y-aa.y, dd.x-aa.x, dd.y-aa.y))	{		return true;	}	return false;  } 