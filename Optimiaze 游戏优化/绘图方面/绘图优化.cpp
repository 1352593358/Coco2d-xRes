1. 使用各自的纹理来创建精灵，由此导致的纹理过小和纹理切换次数过多是产生瓶颈的根源。针对这
个问题，一个简单的解决方案是碎图合并与精灵框帧。碎图合并可以将许多零碎的小图片合并到一张大图里，并且这张大
图的大小恰好符合OpenGL的纹理规范，从空间上减少无谓的浪费。框帧是纹理中的一部分，当我们把小纹理合并好之后就
可以利用精灵框帧来创建精灵了。
CCSpriteFrameCache::sharedSpriteFrameCache()->addSpriteFramesWithFile("all.plist");
2. 有了足够大的纹理图后，就可以考虑从渲染次数上进一步优化了。如果不需要切换绑定纹理，那么几个OpenGL的渲染请求
是可以批量提交的，也就是说，在同一纹理下的绘制都可以一次提交完成。在Cocos2d-x中，我们提供了CCSpriteBatchNode
来实现这一优化。 
3. 在一些低端设备上依然难以让游戏流畅地运行起来。为高端设备准备的纹理资源
色彩深度较高，运行时占用大量的内存或显存，而低端设备的内存或显存空间不足，游戏运行时会表现得十分缓慢，甚至
无法运行，这是一个十分常见的问题。这个时候我们不得不考虑从资源质量的角度做一些优化了。  
	很多时候我们希望控制游戏包的尺寸，以方便玩家下载游戏。在我们已经把纹理尺寸优化到极致后，降低色彩
深度就是继续减小游戏尺寸唯一的选择了。幸运的是，TexturePacker提供了方便的功能来压缩色彩深度，从而减少资源的
占用。
	默认情况下，我们导出的纹理图片是RGBA8888格式的，它的含义是每个像素的红、蓝、绿、不透明度4个值分别占用8比	
特（相当于1字节），因此一个像素总共需要使用4个字节表示。若降低纹理的品质，则可以采用RGBA4444格式（如图10-10
所示）来保存图片。RGBA4444图片的每一个像素中每个分量只占用4比特，因此一个像素总共占用2字节，图片大小将整
整减少一半。对于不透明的图片，我们可以选择无Alpha通道的颜色格式，例如RGB565，可以在不增加尺寸的同时提高图
像品质。各种图像编辑器通常都可以修改图片的色彩深度，TexturePacker也提供了这个功能。 
	